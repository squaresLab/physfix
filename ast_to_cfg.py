"""Converting Statement objects into CFGs"""
from __future__ import annotations

import json
from abc import ABC, abstractmethod
from typing import Dict, List, Set, Tuple

import attr
import yaml

from physfix.parse.cpp_parser import Token
from physfix.parse.cpp_utils import get_statement_tokens, token_to_stmt_str, tokens_to_str
from physfix.parse.dump_to_ast import DumpToAST, FunctionDeclaration, Statement


class CFGNode(ABC):
    """Abstract class for CFGNode"""
    next: Set[CFGNode]
    previous: Set[CFGNode]

    @abstractmethod
    def get_type(self):
        """Returns type of CFGNode"""
        raise NotImplementedError

    def to_dict(self) -> Dict:
        """Serializes CFGNode to dictionary"""
        raise NotImplementedError


class FunctionCFG:
    """CFGNode for Function"""
    def __init__(self, function_declaration: FunctionDeclaration, entry_block: EntryBlock):
        self.function_declaration = function_declaration
        self.entry_block = entry_block
        self.nodes = []

    def create_node_mapping(self) -> Dict[CFGNode, int]:
        """Creates a mapping from a CFGNode to a unique int.
        IDs are the index of the CFGNode in self.nodes
        """
        node_mapping = {}
        for idx, n in enumerate(self.nodes):
            node_mapping[n] = idx

        return node_mapping

    def create_adjacency_list(self) -> Dict[int]:
        """Creates adjacency list for nodes using mapping generated by 
        create_node_mapping
        """
        node_mapping = self.create_node_mapping()

        adjacency_list = {}
        for n in self.nodes:
            next_ids = []
            for next_n in n.next:
                next_ids.append(node_mapping[next_n])

            previous_ids = []
            for prev_n in n.previous:
                previous_ids.append(node_mapping[prev_n])

            adjacency_list[node_mapping[n]] = {
                "next": sorted(next_ids),
                "previous": sorted(previous_ids)
            }

        return adjacency_list

    def to_dict(self) -> List[Dict]:
        """Serializes nodes of CFG into maping of node IDs to CFGNodes"""
        serialized_nodes_dict: Dict[int, Dict] = {}
        node_mapping = self.create_node_mapping()
        adjacency_list = self.create_adjacency_list()

        for n, id in node_mapping.items():
            serialized_n = n.to_dict()
            next_ids = adjacency_list[id]["next"]
            previous_ids = adjacency_list[id]["previous"]

            serialized_n["next"] = next_ids
            serialized_n["previous"] = previous_ids

            serialized_nodes_dict[id] = serialized_n

        return serialized_nodes_dict

class EntryBlock(CFGNode):
    """Entry block for a function"""
    def __init__(self, function_declaration: FunctionDeclaration):
        self.next = set()
        self.previous = set()
        self.function_declaration = function_declaration
        self.function_arguments = list(function_declaration.function.argument.values())

    def get_type(self):
        return "entry"

    def __repr__(self):
        return f"EntryBlock(function_name={self.function_declaration.name})"

    def to_dict(self) -> Dict:
        entry_dict = {
            self.get_type(): {
                "name": self.function_declaration.name,
                "arguments": [v.nameToken.str for v in self.function_arguments],
            }
        }

        return entry_dict


@attr.s(eq=False, repr=False)
class ExitBlock(CFGNode):
    """Exit block for a function"""
    function_declaration: FunctionDeclaration = attr.ib()
    next: Set[CFGNode] = attr.ib(factory=set)
    previous: Set[CFGNode] = attr.ib(factory=set)

    def get_type(self):
        return "exit"

    def __repr__(self):
        return f"ExitBlock(function_name={self.function_declaration.name})"

    def to_dict(self) -> Dict:
        exit_block_dict = {
            self.get_type(): {
                "name": self.function_declaration.name
            }
        }

        return exit_block_dict


@attr.s(eq=False, repr=False)
class BasicBlock(CFGNode):
    """Node for a basic block"""
    token: Token = attr.ib()
    next: Set[CFGNode] = attr.ib(factory=set)
    previous: Set[CFGNode] = attr.ib(factory=set)

    def get_type(self):
        return "basic"

    def __repr__(self):
        return f"BasicBlock(token='{' '.join(token_to_stmt_str(self.token))}')"

    def to_dict(self) -> Dict:
        basic_block_dict = {
            self.get_type(): {
                "token": repr(self.token)
            }
        }

        return basic_block_dict


@attr.s(eq=False, repr=False)
class ConditionalBlock(CFGNode):
    """Node for condition block"""
    condition: Token = attr.ib()
    condition_true: CFGNode = attr.ib()
    condition_false: CFGNode = attr.ib()
    next: Set[CFGNode] = attr.ib(factory=set)
    previous: Set[CFGNode] = attr.ib(factory=set)

    def get_type(self):
        return "conditional"

    def __repr__(self):
        return f"ConditionalBlock(condition={token_to_stmt_str(self.condition)}"

    def to_dict(self) -> Dict:
        condition_block_dict = {
            self.get_type(): {
                "condition": repr(self.condition),
                "condition_true": self.condition_true.to_dict(),
                "condition_false": self.condition_false.to_dict()
            }
        }

        return condition_block_dict


@attr.s(eq=False, repr=False)
class JoinBlock(CFGNode):
    """Node for join block"""
    next: Set[CFGNode] = attr.ib()
    previous: Set[CFGNode] = attr.ib(factory=set)

    def get_type(self):
        return "join"

    def __repr__(self):
        repr_str = "JoinBlock("

        prev_repr_str = []
        for p in self.previous:
            prev_repr_str.append(repr(p))

        repr_str = repr_str + ", ".join(prev_repr_str) + ")"

        return repr_str

    def to_dict(self) -> Dict:
        join_block_dict = {
            self.get_type(): {}
        }

        return join_block_dict


@attr.s(eq=False, repr=False)
class EmptyBlock(CFGNode):
    """Node for empty block"""
    next: Set[CFGNode] = attr.ib(factory=set)
    previous: Set[CFGNode] = attr.ib(factory=set)

    def get_type(self):
        return "empty"

    def __repr__(self):
        return "EmptyBlock()"

    def to_dict(self) -> Dict:
        empty_block_dict = {
            self.get_type(): {}
        }

        return empty_block_dict


class ASTToCFG:
    """Class for converting AST to CFG"""
    def __init__(self):
        pass

    @staticmethod
    def convert_traverse(node: CFGNode) -> List[CFGNode]:
        """Traverses nodes of a CFG"""

        def traverse(path):
            if not path[-1].next:
                return path
            
            cur_node = path[-1]
            if cur_node.get_type() == "basic":
                for t in tokens_to_str(get_statement_tokens(cur_node.token)):
                    if t in ["return", "break", "continue"]:
                        return None
            elif cur_node.get_type() == "exit":
                return None

            for next_node in path[-1].next:
                if next_node in path:
                    continue

                res = traverse(path + [next_node])
                if res:
                    return res

            return None

        return traverse([node])

    @staticmethod
    def convert_statements(statements: List[Statement], call_tree: List[Tuple[str, Statement, Statement]],
                           function_cfg: FunctionCFG) -> EntryBlock:
        """call_tree is order of block calls and each item is tuple of the call + start block of call + the exit/join block of that call"""
        sentinel = EmptyBlock()  # Sentinel node
        cur = sentinel  # Cur node in graph

        for stmt in statements:
            if stmt.get_type() == "block":  # Block statement -> BasicBlock
                # Make basic block, connect to cur, advance cur
                basic_block = BasicBlock(stmt.root_token)
                function_cfg.nodes.append(basic_block)
                basic_block.previous.add(cur)
                cur.next.add(basic_block)
                cur = basic_block

                # Walk through AST to check for break/return/continue
                for t in get_statement_tokens(stmt.root_token):
                    if t.str == "break":
                        assert call_tree, "No call tree"

                        # Find where to break out of
                        last_while = None
                        for i in range(len(call_tree) - 1, -1, -1):
                            if call_tree[i][0] == "while":
                                last_while = call_tree[i]
                                break

                        assert last_while, "Attempted to break with no while"

                        cur.next.add(last_while[2])
                        last_while[2].previous.add(cur)

                        start = sentinel.next.pop()
                        start.previous.remove(sentinel)
                        return start
                    elif t.str == "return":
                        assert call_tree, "No call tree"
                        block_type, _, block_exit = call_tree[0]
                        assert block_type == "function", "Attempted to return outside a function"

                        # Connect return statement to function exit block
                        cur.next.add(block_exit)
                        block_exit.previous.add(cur)

                        start = sentinel.next.pop()
                        start.previous.remove(sentinel)
                        return start
                    elif t.str == "continue":
                        assert call_tree, "No call tree"

                        # Find where to continue to
                        last_while = None
                        for i in range(len(call_tree) - 1, -1, -1):
                            if call_tree[i][0] == "while":
                                last_while = call_tree[i]
                                break

                        assert last_while, "Attempted to continue with no while"

                        cur.next.add(last_while[1])
                        last_while[1].previous.add(cur)

                        start = sentinel.next.pop()
                        start.previous.remove(sentinel)
                        return start

            elif stmt.get_type() == "if":
                cond_block = ConditionalBlock(stmt.condition, None, None)
                function_cfg.nodes.append(cond_block)
                cur.next.add(cond_block)
                cond_block.previous.add(cur)
                join_block = JoinBlock(set())

                # Recursively get true/false nodes
                condition_true = ASTToCFG.convert_statements(stmt.condition_true, call_tree + [("if", cond_block, join_block)],
                                                             function_cfg)
                condition_false = ASTToCFG.convert_statements(stmt.condition_false, call_tree + [("if", cond_block, join_block)],
                                                              function_cfg)

                cond_block.condition_true = condition_true
                cond_block.next.add(condition_true)
                condition_true.previous.add(cond_block)

                condition_true_end = ASTToCFG.convert_traverse(condition_true)

                if condition_true_end is not None:
                    condition_true_end = condition_true_end[-1]
                    condition_true_end.next.add(join_block)
                    join_block.previous.add(condition_true_end)

                cond_block.condition_false = condition_false
                cond_block.next.add(condition_false)
                condition_false.previous.add(cond_block)

                condition_false_end = ASTToCFG.convert_traverse(condition_false)
                if condition_false_end is not None:            
                    condition_false_end = condition_false_end[-1]
                    condition_false_end.next.add(join_block)
                    join_block.previous.add(condition_false_end)

                if condition_false_end or condition_true_end:
                    function_cfg.nodes.append(join_block)
                
                cur = join_block
            elif stmt.get_type() == "while":
                cond_block = ConditionalBlock(stmt.condition, None, None)
                function_cfg.nodes.append(cond_block)
                cur.next.add(cond_block)
                cond_block.previous.add(cur)
                join_block = JoinBlock(set())

                # Recursively get true/false nodes
                condition_true = ASTToCFG.convert_statements(stmt.condition_true, call_tree + [("while", cond_block, join_block)],
                                                             function_cfg)
                condition_false = EmptyBlock()
                function_cfg.nodes.append(condition_false)

                # Connect true/false to conditional
                cond_block.condition_true = condition_true
                cond_block.next.add(condition_true)
                condition_true.previous.add(cond_block)
                cond_block.condition_false = condition_false
                cond_block.next.add(condition_false)
                condition_false.previous.add(cond_block)

                # Traverse to end of conditionals
                condition_true_end = ASTToCFG.convert_traverse(condition_true)
                if condition_true_end:
                    condition_true_end = condition_true_end[-1]

                    if condition_true_end.get_type() == "basic" and "break" not in token_to_stmt_str(condition_true_end.token):
                        condition_true_end.next.add(cond_block)
                        cond_block.previous.add(condition_true_end)
                    elif condition_true_end.get_type() != "basic":
                        condition_true_end.next.add(cond_block)
                        cond_block.previous.add(condition_true_end)

                condition_false_end = condition_false  # End of empty block is just the empty block

                # Connect false to join
                condition_false_end.next.add(join_block)
                join_block.previous.add(condition_false_end)

                if condition_true_end or condition_false_end:
                    function_cfg.nodes.append(join_block)

                cur = join_block
            else:
                raise ValueError(f"Unexpected statement: {stmt.get_type()}")

        if call_tree and len(call_tree) == 1 and call_tree[0][0] == "function":  # If we're in the top level function block
            function_exit_block = call_tree[0][2]

            if cur.previous:  # Check that cur isn't dangling
                cur.next.add(function_exit_block)
                function_exit_block.previous.add(cur)

        if sentinel.next:
            assert len(sentinel.next) == 1, "Too many nodes"

            start = sentinel.next.pop()
            start.previous.pop()
            return start

        empty_return = EmptyBlock()
        function_cfg.nodes.append(empty_return)
        return empty_return

    @staticmethod
    def convert(dump_file_path: str) -> List[FunctionCFG]:
        """Takes a dump file path and creates a CFG for each function"""
        function_declaration_objs = DumpToAST().convert(dump_file_path)
        function_CFG = []

        for f in function_declaration_objs:
            entry_block = EntryBlock(f)
            exit_block = ExitBlock(f)
            f_cfg = FunctionCFG(f, entry_block)
            f_cfg.nodes.append(entry_block)

            body = ASTToCFG.convert_statements(f.body, [(f.get_type(), entry_block, exit_block)], f_cfg)
            entry_block.next.add(body)

            if body:
                body.previous.add(entry_block)

            f_cfg.nodes.append(exit_block)
            function_CFG.append(f_cfg)

        return function_CFG

    @staticmethod
    def write(cfgs: List[FunctionCFG], file_name: str, serialize_format="yaml"):
        """Serializes FunctionDeclaration objects to yaml/json"""
        objs_dict: Dict = [c.to_dict() for c in cfgs]

        if serialize_format == "yaml":
            with open(file_name, "w", encoding="utf-8") as f:
                yaml.dump(objs_dict, f)
        elif serialize_format == "json":
            with open(file_name, "w", encoding="utf-8") as f:
                json.dump(objs_dict, f)
        else:
            raise ValueError("Format should be json or yaml")


if __name__ == "__main__":
    # e_count = 0
    # test_path = f"/home/rewong/phys/ryan/control_flow/ast_to_cfg_test/test_12.cpp.dump"
    # parsed = ASTToCFG.convert(test_path)
    # print(parsed[0].nodes)
    # print(parsed[0].to_dict())
    # ASTToCFG.write(parsed, "test_2.yaml")
    e_count = 0
    with open("dump_files.txt") as f:
        for idx, l in enumerate(f.readlines()):
            print(idx)
            try:
                test_path = f"/home/rewong/{l.rstrip()}"
                parsed = ASTToCFG.convert(test_path)
            except Exception as e:
                print(test_path)
                print(e)
                e_count += 1
    print(e_count)
    
    # print(e_count)
    # x = parsed[0].next.pop().next.pop().condition_false.next.pop().previous
    # x = list(list(parsed[0].next)[0].next)[0].condition_true.condition_false.next.pop().next
    # y = list(list(list(parsed[0].next)[0].next)[0].condition_false.next)[0]
    # print(tokens_to_str(get_statement_tokens(x.condition)))
    # print(x)
    # for i in x:
    #     if i.get_type() == "conditional":
    #         for j in i.next:
    #             print(j.next.pop().next.pop().previous, j.get_type())
    # print(tokens_to_str(get_statement_tokens(parsed[0].next.pop().next.pop().next.pop().next.pop().next.pop().next)))

    # print([x.scope_obj.type for x in parsed[0].scope_tree.children])

    # cur = [parsed[0].scope_tree]
    # while cur:
    #     x = cur.pop(0)
    #     print(x.scope_id)
    #     print([z.scope_id for z in x.children])
    #     cur.extend(x.children)

    # print_AST(parsed[0].body)
    # print(parsed[0].body[-1].condition_true[2])
    # print_AST(parsed[0].body[-1].match_true[-1].match_true)
    # for b in parsed[0].body:
    #     print("_____")
    #     if b.type == "block":
    #         print(tokens_to_str(get_statement_tokens(b.root_token)))
    #     elif b.type == "if":
    #         print(tokens_to_str(get_statement_tokens(b.condition)))
    #         print(b.condition_true)
            # print(tokens_to_str(get_statement_tokens(b.condition_true)))
            # print(tokens_to_str(get_statement_tokens(b.condition_false)))
